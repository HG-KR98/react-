{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\\\uAE40\\uD5CC\\uADDC\\\\Desktop\\\\\\uB9AC\\uC561\\uD2B8 \\uACF5\\uBD80\\\\react-\\\\react-route-upgrade\\\\frontend\\\\src\\\\pages\\\\Event.js\",\n  _s = $RefreshSig$();\nimport { useLoaderData, json, defer, Await } from \"react-router-dom\";\nimport EventsList from \"../components/EventsList\";\nimport { Suspense } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction EventsPage() {\n  _s();\n  // const data = useLoaderData();\n  const {\n    events\n  } = useLoaderData();\n\n  // // 커스텀 오류를 이용한 오류 처리\n  // if (data.isError) {\n  //   return <p>{data.message}</p>;\n  // }\n  // const events = data.events;\n  // return <EventsList events={events} />;\n\n  // 연기된 값을 처리\n  // resolve에 넣은 데이터가 올때까지 기다리고 이어서 시작 태그와 종료 태그 사이에서 역동적인 값을 출력한다.\n  return (\n    /*#__PURE__*/\n    // Suspense 컴포넌트는 다른 데이터가 도착하길 기다리는 동안에 폴백을 보여주는 특정한 상황에서 사용할 수 있다.\n    _jsxDEV(Suspense, {\n      fallback: /*#__PURE__*/_jsxDEV(\"p\", {\n        style: {\n          textAlign: \"center\"\n        },\n        children: \"Loading...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 20,\n        columnNumber: 25\n      }, this),\n      children: /*#__PURE__*/_jsxDEV(Await, {\n        resolve: events,\n        children: loadedEvents => /*#__PURE__*/_jsxDEV(EventsList, {\n          events: loadedEvents\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 22,\n          columnNumber: 28\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 21,\n        columnNumber: 7\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 20,\n      columnNumber: 5\n    }, this)\n  );\n}\n_s(EventsPage, \"xTcuS98fsVcq20se00iLm8bDBmQ=\", false, function () {\n  return [useLoaderData];\n});\n_c = EventsPage;\nexport default EventsPage;\nasync function loadEvents() {\n  const response = await fetch(\"http://localhost:8080/events\");\n  if (!response.ok) {\n    return json({\n      message: \"Could not fetch events.\"\n    }, {\n      status: 500\n    });\n  } else {\n    // defer를 사용할 경우 직접 response를 받을 수 없기 때문에 파싱을 해주어야 한다. loader\n    //return response;\n    const resData = await response.json();\n    return resData.events;\n  }\n}\n\n// 이 loader 코드는 서버에서 실행되지 않는다. (브라우저에서만 실행됨.)\n// 그럼에도 Response 생성자를 생성할 수 있는 이유는 브라우저에서 기능을 지원하기 때문이다.\nexport function loader() {\n  // const response = await fetch(\"http://localhost:8080/events\");\n  // if (!response.ok) {\n  //   // 커스텀 오류를 이용한 오류 처리\n  //   // 첫번째 방법 : return { isError: true, message: \"Could not fetch events.\" };\n  //   // 두번째 방법 : throw new Error();\n  //   // 리액트 라우터는 간단히 가장 근접한 오류 요소를 렌더링한다.\n  //   // 우리는 404 오류와 다른 오류들을, 우리 loader에 있는 오류와 구분할 수도 있다.\n  //   // 오류들을 구분하기 위해 우리는 객체를 throw하는 대신에 new Response()를 throw할 수 있다.\n  //   // throw { message: \"Coule not fetch events.\" };\n  //   // 이렇게 Response로 일일히 길게 작성하면 귀찮기 때문에 react-router에서는\n  //   // json()이라는 작은 헬퍼 유틸리티를 제공한다.\n  //   // throw new Response(JSON.stringify({ message: \"Could not fetch events.\" }), {\n  //   //   status: 500,\n  //   // });\n  //   // json()은 json 형식의 데이터가 포함된 Response 객체를 생성하는 함수이다.\n  //   return json({ message: \"Could not fetch events.\" }, { status: 500 });\n  // } else {\n  //   // const resData = await response.json();\n  //   // Response의 첫번째 인자는 어떠한 데이터도 받는 인자이며\n  //   // 두번째 인자는 설정할 수 있는 추가 객체를 이용해서 그걸 더욱 자세히 설정할 수 있다.\n  //   // 예를 들어서 응답 상태 코드를 예시로 들 수 있다.\n  //   // 이러한 Response 생성자를 사용할 때 loader에서 응답을 리턴할 때마다\n  //   // 리액트 라우터 패키지는 useLoaderData를 사용할 때 응답에서 자동으로 데이터를 추출한다.\n  //   // useLoaderData가 리턴하는 데이터는 loader에서 리턴한 응답의 일부인 응답 데이터이다.\n  //   // return resData.event;로도 충분히 별도의 응답 객체를 생성할 수 있다.\n  //   // 이 편이 좀 더 코드도 더 짧다. 하지만 new Response()가 존재하는 이유는\n  //   // 이 loader 함수에서 브라우저에 내장된 fetch 함수로 백엔드에 도달하는 방식을\n  //   // 상당히 널리 사용하기 때문이다. fetch 함수는 실제로 Response로 리졸빙 되는\n  //   // Promise를 리턴한다. 더구나 리액트 라우터는 이런 응답 객체들을 지원하고 자동으로 데이터를\n  //   // 추출하기 때문에 간단히 말하자면 여기서 받는 response 즉 이 응답 객체를 취해서\n  //   // 그걸 우리의 loader에서 리턴할 수 있다. 우리는 이 response에서 수작업으로 데이터를 추출할\n  //   //const data = await fetch(\"http://localhost:8080/events\");\n  //   // const events = data.events;\n  //   // return response;\n  //   // 필요가 없다. 대신에 위의 식으로 문제 없는지 확인하거나 확인하지 않고서 response를 리턴할 수 있다.\n  //   // 위의 방식으로 response를 리턴한다면 useLoaderData는 response의 일부인 데이터를 자동으로 우리에게 준다.\n  //   // 이렇게 하면 loader 코드도 줄일 수 있고 내장된 응답 객체에 대한 지원을 활용할 수 있게 된다.\n  //   return response;\n  // }\n\n  // 우리는 defer 객체에 이 페이지에서 오갈 수 있는 모든 HTTP 요청을 넣어줘야 한다.\n  return defer({\n    events: loadEvents()\n  });\n}\nvar _c;\n$RefreshReg$(_c, \"EventsPage\");","map":{"version":3,"names":["useLoaderData","json","defer","Await","EventsList","Suspense","jsxDEV","_jsxDEV","EventsPage","_s","events","fallback","style","textAlign","children","fileName","_jsxFileName","lineNumber","columnNumber","resolve","loadedEvents","_c","loadEvents","response","fetch","ok","message","status","resData","loader","$RefreshReg$"],"sources":["C:/Users/김헌규/Desktop/리액트 공부/react-/react-route-upgrade/frontend/src/pages/Event.js"],"sourcesContent":["import { useLoaderData, json, defer, Await } from \"react-router-dom\";\r\nimport EventsList from \"../components/EventsList\";\r\nimport { Suspense } from \"react\";\r\n\r\nfunction EventsPage() {\r\n  // const data = useLoaderData();\r\n  const { events } = useLoaderData();\r\n\r\n  // // 커스텀 오류를 이용한 오류 처리\r\n  // if (data.isError) {\r\n  //   return <p>{data.message}</p>;\r\n  // }\r\n  // const events = data.events;\r\n  // return <EventsList events={events} />;\r\n\r\n  // 연기된 값을 처리\r\n  // resolve에 넣은 데이터가 올때까지 기다리고 이어서 시작 태그와 종료 태그 사이에서 역동적인 값을 출력한다.\r\n  return (\r\n    // Suspense 컴포넌트는 다른 데이터가 도착하길 기다리는 동안에 폴백을 보여주는 특정한 상황에서 사용할 수 있다.\r\n    <Suspense fallback={<p style={{ textAlign: \"center\" }}>Loading...</p>}>\r\n      <Await resolve={events}>\r\n        {(loadedEvents) => <EventsList events={loadedEvents} />}\r\n      </Await>\r\n    </Suspense>\r\n  );\r\n}\r\n\r\nexport default EventsPage;\r\n\r\nasync function loadEvents() {\r\n  const response = await fetch(\"http://localhost:8080/events\");\r\n\r\n  if (!response.ok) {\r\n    return json({ message: \"Could not fetch events.\" }, { status: 500 });\r\n  } else {\r\n    // defer를 사용할 경우 직접 response를 받을 수 없기 때문에 파싱을 해주어야 한다. loader\r\n    //return response;\r\n    const resData = await response.json();\r\n    return resData.events;\r\n  }\r\n}\r\n\r\n// 이 loader 코드는 서버에서 실행되지 않는다. (브라우저에서만 실행됨.)\r\n// 그럼에도 Response 생성자를 생성할 수 있는 이유는 브라우저에서 기능을 지원하기 때문이다.\r\nexport function loader() {\r\n  // const response = await fetch(\"http://localhost:8080/events\");\r\n  // if (!response.ok) {\r\n  //   // 커스텀 오류를 이용한 오류 처리\r\n  //   // 첫번째 방법 : return { isError: true, message: \"Could not fetch events.\" };\r\n  //   // 두번째 방법 : throw new Error();\r\n  //   // 리액트 라우터는 간단히 가장 근접한 오류 요소를 렌더링한다.\r\n  //   // 우리는 404 오류와 다른 오류들을, 우리 loader에 있는 오류와 구분할 수도 있다.\r\n  //   // 오류들을 구분하기 위해 우리는 객체를 throw하는 대신에 new Response()를 throw할 수 있다.\r\n  //   // throw { message: \"Coule not fetch events.\" };\r\n  //   // 이렇게 Response로 일일히 길게 작성하면 귀찮기 때문에 react-router에서는\r\n  //   // json()이라는 작은 헬퍼 유틸리티를 제공한다.\r\n  //   // throw new Response(JSON.stringify({ message: \"Could not fetch events.\" }), {\r\n  //   //   status: 500,\r\n  //   // });\r\n  //   // json()은 json 형식의 데이터가 포함된 Response 객체를 생성하는 함수이다.\r\n  //   return json({ message: \"Could not fetch events.\" }, { status: 500 });\r\n  // } else {\r\n  //   // const resData = await response.json();\r\n  //   // Response의 첫번째 인자는 어떠한 데이터도 받는 인자이며\r\n  //   // 두번째 인자는 설정할 수 있는 추가 객체를 이용해서 그걸 더욱 자세히 설정할 수 있다.\r\n  //   // 예를 들어서 응답 상태 코드를 예시로 들 수 있다.\r\n  //   // 이러한 Response 생성자를 사용할 때 loader에서 응답을 리턴할 때마다\r\n  //   // 리액트 라우터 패키지는 useLoaderData를 사용할 때 응답에서 자동으로 데이터를 추출한다.\r\n  //   // useLoaderData가 리턴하는 데이터는 loader에서 리턴한 응답의 일부인 응답 데이터이다.\r\n  //   // return resData.event;로도 충분히 별도의 응답 객체를 생성할 수 있다.\r\n  //   // 이 편이 좀 더 코드도 더 짧다. 하지만 new Response()가 존재하는 이유는\r\n  //   // 이 loader 함수에서 브라우저에 내장된 fetch 함수로 백엔드에 도달하는 방식을\r\n  //   // 상당히 널리 사용하기 때문이다. fetch 함수는 실제로 Response로 리졸빙 되는\r\n  //   // Promise를 리턴한다. 더구나 리액트 라우터는 이런 응답 객체들을 지원하고 자동으로 데이터를\r\n  //   // 추출하기 때문에 간단히 말하자면 여기서 받는 response 즉 이 응답 객체를 취해서\r\n  //   // 그걸 우리의 loader에서 리턴할 수 있다. 우리는 이 response에서 수작업으로 데이터를 추출할\r\n  //   //const data = await fetch(\"http://localhost:8080/events\");\r\n  //   // const events = data.events;\r\n  //   // return response;\r\n  //   // 필요가 없다. 대신에 위의 식으로 문제 없는지 확인하거나 확인하지 않고서 response를 리턴할 수 있다.\r\n  //   // 위의 방식으로 response를 리턴한다면 useLoaderData는 response의 일부인 데이터를 자동으로 우리에게 준다.\r\n  //   // 이렇게 하면 loader 코드도 줄일 수 있고 내장된 응답 객체에 대한 지원을 활용할 수 있게 된다.\r\n  //   return response;\r\n  // }\r\n\r\n  // 우리는 defer 객체에 이 페이지에서 오갈 수 있는 모든 HTTP 요청을 넣어줘야 한다.\r\n  return defer({\r\n    events: loadEvents(),\r\n  });\r\n}\r\n"],"mappings":";;AAAA,SAASA,aAAa,EAAEC,IAAI,EAAEC,KAAK,EAAEC,KAAK,QAAQ,kBAAkB;AACpE,OAAOC,UAAU,MAAM,0BAA0B;AACjD,SAASC,QAAQ,QAAQ,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEjC,SAASC,UAAUA,CAAA,EAAG;EAAAC,EAAA;EACpB;EACA,MAAM;IAAEC;EAAO,CAAC,GAAGV,aAAa,CAAC,CAAC;;EAElC;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;IAAA;IACE;IACAO,OAAA,CAACF,QAAQ;MAACM,QAAQ,eAAEJ,OAAA;QAAGK,KAAK,EAAE;UAAEC,SAAS,EAAE;QAAS,CAAE;QAAAC,QAAA,EAAC;MAAU;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAG,CAAE;MAAAJ,QAAA,eACpEP,OAAA,CAACJ,KAAK;QAACgB,OAAO,EAAET,MAAO;QAAAI,QAAA,EACnBM,YAAY,iBAAKb,OAAA,CAACH,UAAU;UAACM,MAAM,EAAEU;QAAa;UAAAL,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAE;MAAC;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAClD;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACA;EAAC;AAEf;AAACT,EAAA,CArBQD,UAAU;EAAA,QAEER,aAAa;AAAA;AAAAqB,EAAA,GAFzBb,UAAU;AAuBnB,eAAeA,UAAU;AAEzB,eAAec,UAAUA,CAAA,EAAG;EAC1B,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAC,8BAA8B,CAAC;EAE5D,IAAI,CAACD,QAAQ,CAACE,EAAE,EAAE;IAChB,OAAOxB,IAAI,CAAC;MAAEyB,OAAO,EAAE;IAA0B,CAAC,EAAE;MAAEC,MAAM,EAAE;IAAI,CAAC,CAAC;EACtE,CAAC,MAAM;IACL;IACA;IACA,MAAMC,OAAO,GAAG,MAAML,QAAQ,CAACtB,IAAI,CAAC,CAAC;IACrC,OAAO2B,OAAO,CAAClB,MAAM;EACvB;AACF;;AAEA;AACA;AACA,OAAO,SAASmB,MAAMA,CAAA,EAAG;EACvB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA,OAAO3B,KAAK,CAAC;IACXQ,MAAM,EAAEY,UAAU,CAAC;EACrB,CAAC,CAAC;AACJ;AAAC,IAAAD,EAAA;AAAAS,YAAA,CAAAT,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}