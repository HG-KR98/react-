{"ast":null,"code":"import { createStore } from \"redux\";\n// createSlice가 createReducer보다 더 강력하다.\nimport { createSlice } from \"@reduxjs/toolkit\";\nconst initialState = {\n  counter: 0,\n  showCounter: true\n};\ncreateSlice({\n  name: \"counter\",\n  initialState,\n  reducers: {\n    increment(state) {\n      // Redux만 사용할 때는 이런식으로 상태를 직접 변경하면 안됐으나 tootkit과\n      // 같이 사용하면 toolkit이 immer라는 다른 패키지를 사용하는데 이런 코드를 감지하고\n      // 자동으로 원래 있는 상태를 복제한다. 그리고 새로운 상태 객체를 생성하고 모든 상태를 변경할 수 없게 유지하고,\n      // 우리가 변경한 상태는 변하지 않도록 오버라이드 한다.\n      state.counter++;\n    },\n    decrement(state) {},\n    increase() {},\n    toggleCounter() {}\n  }\n});\n\n// 상태를 업데이트 할때는 기존의 값을 덮어씌운다는 개념이다.\nconst counterReducer = (state = initialState, action) => {\n  if (action.type === \"increment\") {\n    // 밑의 코드로 작성하면 작동은 하는데 잘못된 방법인 이유는\n    // Redux로 작업할 때 절대로 해서는 안되는 것이며 절대 기존의 state를\n    // 변형해서는 안되기 때문이다. 새로운 state 객체를 반환하여 항상 재정의 하는 방법을 사용해야한다.\n    // javaScript에서는 객체나 배열이 참조 값\n    // state.counter++;\n    // return state;\n\n    return {\n      counter: state.counter + 1,\n      showCounter: state.showCounter\n    };\n  }\n  if (action.type === \"increase\") {\n    return {\n      counter: state.counter + action.amount,\n      howCounter: state.showCounter\n    };\n  }\n  if (action.type === \"decrement\") {\n    return {\n      counter: state.counter - 1,\n      showCounter: state.showCounter\n    };\n  }\n  if (action.type === \"toggle\") {\n    return {\n      counter: state.counter,\n      howCounter: !state.showCounter\n    };\n  }\n  return state;\n};\nconst store = redux.createStore(counterReducer);\n\n// const counterSubscriber = () => {\n//   const latestState = store.getState();\n//   console.log(latestState);\n// };\n\n// store.subscribe(counterSubscriber);\n\n// store.dispatch({ type: \"increment\" });\n// store.dispatch({ type: \"decrement\" });\n\nexport default store;","map":{"version":3,"names":["createStore","createSlice","initialState","counter","showCounter","name","reducers","increment","state","decrement","increase","toggleCounter","counterReducer","action","type","amount","howCounter","store","redux"],"sources":["C:/Users/김헌규/Desktop/리액트 공부/react-/redux-project/src/store/index.js"],"sourcesContent":["import { createStore } from \"redux\";\r\n// createSlice가 createReducer보다 더 강력하다.\r\nimport { createSlice } from \"@reduxjs/toolkit\";\r\n\r\nconst initialState = { counter: 0, showCounter: true };\r\n\r\ncreateSlice({\r\n  name: \"counter\",\r\n  initialState,\r\n  reducers: {\r\n    increment(state) {\r\n      // Redux만 사용할 때는 이런식으로 상태를 직접 변경하면 안됐으나 tootkit과\r\n      // 같이 사용하면 toolkit이 immer라는 다른 패키지를 사용하는데 이런 코드를 감지하고\r\n      // 자동으로 원래 있는 상태를 복제한다. 그리고 새로운 상태 객체를 생성하고 모든 상태를 변경할 수 없게 유지하고,\r\n      // 우리가 변경한 상태는 변하지 않도록 오버라이드 한다.\r\n      state.counter++;\r\n    },\r\n    decrement(state) {},\r\n    increase() {},\r\n    toggleCounter() {},\r\n  },\r\n});\r\n\r\n// 상태를 업데이트 할때는 기존의 값을 덮어씌운다는 개념이다.\r\nconst counterReducer = (state = initialState, action) => {\r\n  if (action.type === \"increment\") {\r\n    // 밑의 코드로 작성하면 작동은 하는데 잘못된 방법인 이유는\r\n    // Redux로 작업할 때 절대로 해서는 안되는 것이며 절대 기존의 state를\r\n    // 변형해서는 안되기 때문이다. 새로운 state 객체를 반환하여 항상 재정의 하는 방법을 사용해야한다.\r\n    // javaScript에서는 객체나 배열이 참조 값\r\n    // state.counter++;\r\n    // return state;\r\n\r\n    return {\r\n      counter: state.counter + 1,\r\n      showCounter: state.showCounter,\r\n    };\r\n  }\r\n\r\n  if (action.type === \"increase\") {\r\n    return {\r\n      counter: state.counter + action.amount,\r\n      howCounter: state.showCounter,\r\n    };\r\n  }\r\n\r\n  if (action.type === \"decrement\") {\r\n    return {\r\n      counter: state.counter - 1,\r\n      showCounter: state.showCounter,\r\n    };\r\n  }\r\n\r\n  if (action.type === \"toggle\") {\r\n    return {\r\n      counter: state.counter,\r\n      howCounter: !state.showCounter,\r\n    };\r\n  }\r\n\r\n  return state;\r\n};\r\n\r\nconst store = redux.createStore(counterReducer);\r\n\r\n// const counterSubscriber = () => {\r\n//   const latestState = store.getState();\r\n//   console.log(latestState);\r\n// };\r\n\r\n// store.subscribe(counterSubscriber);\r\n\r\n// store.dispatch({ type: \"increment\" });\r\n// store.dispatch({ type: \"decrement\" });\r\n\r\nexport default store;\r\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ,OAAO;AACnC;AACA,SAASC,WAAW,QAAQ,kBAAkB;AAE9C,MAAMC,YAAY,GAAG;EAAEC,OAAO,EAAE,CAAC;EAAEC,WAAW,EAAE;AAAK,CAAC;AAEtDH,WAAW,CAAC;EACVI,IAAI,EAAE,SAAS;EACfH,YAAY;EACZI,QAAQ,EAAE;IACRC,SAASA,CAACC,KAAK,EAAE;MACf;MACA;MACA;MACA;MACAA,KAAK,CAACL,OAAO,EAAE;IACjB,CAAC;IACDM,SAASA,CAACD,KAAK,EAAE,CAAC,CAAC;IACnBE,QAAQA,CAAA,EAAG,CAAC,CAAC;IACbC,aAAaA,CAAA,EAAG,CAAC;EACnB;AACF,CAAC,CAAC;;AAEF;AACA,MAAMC,cAAc,GAAGA,CAACJ,KAAK,GAAGN,YAAY,EAAEW,MAAM,KAAK;EACvD,IAAIA,MAAM,CAACC,IAAI,KAAK,WAAW,EAAE;IAC/B;IACA;IACA;IACA;IACA;IACA;;IAEA,OAAO;MACLX,OAAO,EAAEK,KAAK,CAACL,OAAO,GAAG,CAAC;MAC1BC,WAAW,EAAEI,KAAK,CAACJ;IACrB,CAAC;EACH;EAEA,IAAIS,MAAM,CAACC,IAAI,KAAK,UAAU,EAAE;IAC9B,OAAO;MACLX,OAAO,EAAEK,KAAK,CAACL,OAAO,GAAGU,MAAM,CAACE,MAAM;MACtCC,UAAU,EAAER,KAAK,CAACJ;IACpB,CAAC;EACH;EAEA,IAAIS,MAAM,CAACC,IAAI,KAAK,WAAW,EAAE;IAC/B,OAAO;MACLX,OAAO,EAAEK,KAAK,CAACL,OAAO,GAAG,CAAC;MAC1BC,WAAW,EAAEI,KAAK,CAACJ;IACrB,CAAC;EACH;EAEA,IAAIS,MAAM,CAACC,IAAI,KAAK,QAAQ,EAAE;IAC5B,OAAO;MACLX,OAAO,EAAEK,KAAK,CAACL,OAAO;MACtBa,UAAU,EAAE,CAACR,KAAK,CAACJ;IACrB,CAAC;EACH;EAEA,OAAOI,KAAK;AACd,CAAC;AAED,MAAMS,KAAK,GAAGC,KAAK,CAAClB,WAAW,CAACY,cAAc,CAAC;;AAE/C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,eAAeK,KAAK","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}